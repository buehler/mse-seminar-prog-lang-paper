When we apply ``simple types'' to the purely untyped
$\lambda$-Calculus, the result is the ``pure simply typed $\lambda$-Calculus''.
This could count as a programming language since we can perform
all basic operations a computation needs. We're also able to analyze
the code and calculate the types needed for functions and variables
and therefore can categorize our programs into meaningful and
meaningless ones. To make the syntax more useful however, we can extend
our simple types with ``simple extensions'' which do not include any
form of polymorphism. Those extensions make our language and the type
checker more useful and able to perform operations.

The following sections will explain such extensions and how they are constructed.
For the further reading, the rules of the ``pure simply typed $\lambda$-Calculus''
are stated again \cite{pierce2002ProgLang}.

\subsubsection{Syntax}
\begin{bnfgrammar}
    t ::= : terms$\colon$
    | x : variable
    | $\lambda$x$\colon$T . t : abstraction
    | t t : application
\end{bnfgrammar}\leavevmode\newline

\begin{bnfgrammar}
    v ::= : values$\colon$
    | $\lambda$x$\colon$T . t : abstraction value
\end{bnfgrammar}\leavevmode\newline

\begin{bnfgrammar}
    T ::= : types$\colon$
    | T$\rightarrow$T : type of functions
\end{bnfgrammar}\leavevmode\newline

\begin{bnfgrammar}
    $\Gamma$ ::= : contexts$\colon$
    | $\varnothing$ : empty context
    | $\Gamma$, x$\colon$T : term variable binding
\end{bnfgrammar}\leavevmode\newline

\subsubsection{Evaluation}
\begin{equation*}
    \tag{Application 1}
    \infer{
        t_1 t_2 \rightarrow t'_1 t_2
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
``If there exists an evaluation step from $t_1$ to $t'_1$ take this step
prior to the evaluation step of $t_2$''. This forces the program, to first
evaluate all terms of $t_1$ until the next rule hits.

\begin{equation*}
    \tag{Application 2}
    \infer{
        v_1 t_2 \rightarrow v_1 t'_2
    }{
        t_2 \rightarrow t'_2
    }
\end{equation*}
``If there exists an evaluation step from $t_2$ to $t'_2$ and the left
side of the application is already a value, take this step''. This defines
that when the lefthand side of the application is reduced to a value, evaluate
the righthand side.

\begin{equation*}
    \tag{Application Abstraction}
    (\lambda x \colon T_{11} . t_{12}) v_2 \rightarrow [x \mapsto v_2] t_{12}
\end{equation*}
``Replace the variable $x$ with the value $v_2$ in the term $t_{12}$''. This represents
the effective computation or application of the value to a term.

\subsubsection{Typing}
\begin{equation*}
    \tag{Variable}
    \infer{
        \Gamma \vdash x \colon \texttt{T}
    }{
        x \colon \texttt{T} \in \Gamma
    }
\end{equation*}

\begin{equation*}
    \tag{Application}
    \infer{
        \Gamma \vdash t_1 t_2 \colon \texttt{T}_{12}
    }{
        \Gamma \vdash t_1 \colon \texttt{T}_{11} \rightarrow \texttt{T}_{12}
        &
        \Gamma \vdash t_2 \colon \texttt{T}_{11}
    }
\end{equation*}

\begin{equation*}
    \tag{Abstraction}
    \infer{
        \Gamma \vdash \lambda x \colon \texttt{T}_1 . t_2 \colon \texttt{T}_1 \rightarrow \texttt{T}_2
    }{
        \Gamma,x \colon \texttt{T}_1 \vdash t_2 \colon \texttt{T}_2
    }
\end{equation*}

This in combination with base and function types will be the
cornerstone of the ``simple extensions'' which we will see in the
next sections. Those sections will introduce new elements to the given
categories (``syntax'', ``evaluation'', ``typing'').
