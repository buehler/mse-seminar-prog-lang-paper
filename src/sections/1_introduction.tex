\section{Introduction}

% \begin{quote}
%     Well-typed programs cannot ``go wrong''.
% \end{quote}

All modern programming languages have type systems.
They are either of a more dynamic nature - like JavaScript -
or statically typed like C\#. Functional languages like Haskell have
an even stricter form of a type system. They all have one thing in
common: They aid the developer to create programs, without the
constant fear about runtime errors.

This paper shall give the reader an idea of the steps that
are needed to create a type system and how it is applied to
an untyped language. This paper will use JavaScript and TypeScript\footnote{\url{https://www.typescriptlang.org/}}
as examples for certain comparisons.
Of course, JavaScript is not an untyped language, but
it does not have a strict static type analysis which can lead
to runtime errors during interpretation and execution of the code.
TypeScript is a superset of the JavaScript language which fills this
gap and adds a static type analyzer as well as some sort of a compiler
(i.e. transpiler) to the language.

But why type systems are helpful and how they work
is not a trivial question to be answered. Consider
the following code statements:

\begin{minted}{JavaScript}
    foo = "Hello World"
    bar = 42
    foo - bar // NaN (Not a Number)
\end{minted}

As humans, we immediately understand that this statement
is not going to terminate well - assuming we have an untyped
language. Strings and numbers are not
of the same type and cannot be added together. To determine
that this is not going to work, the computer needs to execute
the statements one by one and will encounter a wrong state.
A type system can prevent such errors and create a
human-readable message when compiling such a program.

The reader should have an understanding of programming
languages and a brief understanding of the untyped
$\lambda$-Calculus which is described in the first
chapters of ``Types and Programming Languages'' by
Benjamin C. Pierce \cite{pierce2002ProgLang}.

The following sections will describe the basics of the
$\lambda$-Calculus, what ``types'' and ``simple types'' are
and how they can be applied to the $\lambda$-Calculus to
achieve the ``simply typed $\lambda$-Calculus''.
