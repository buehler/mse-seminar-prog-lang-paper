\section{Introduction}
\label{sec:intro}

\epigraph{
    The road from untyped to typed universes has been followed many times,
    in many different fields, and largely for the same reasons.
}
{Luca Cardelli and Peter Wegner (1985)}

Many modern programming languages have type systems.
They are either of a more dynamic nature - like JavaScript -
or statically typed like C\#. Functional languages like Haskell have
an even stricter form of a type system. They all have one thing in
common: They aid the developer to create programs without
the constant fear of runtime errors.

This paper shall give the reader an idea of the steps that
are needed to create a type system and how it is applied to
an untyped language. This paper delivers the means
The paper does not include any variants of subtyping like polymorphism.

Why type systems are helpful and how they work
is not a trivial question to be answered. Consider
the following code statement:

\begin{minted}{JavaScript}
    foo = "Hello World"
    bar = 42
    foo - bar // NaN (Not a Number)
\end{minted}

As software developers, we understand that this statement
is not going to create the desired output - assuming we have an untyped
language. Strings and numbers are not
of the same type and cannot be subtracted from one another. To determine
that this is not going to work, the computer needs to execute
the statements one by one and - depending on the language - will encounter
a runtime error. A type system can prevent such errors and create a
human-readable message when compiling such a program.

The remainder of this paper will give a further introduction into the topic,
a brief overview over the $\lambda$-Calculus, an overview
over the topic of ``types'' in general, and the application
of simple types to the untyped $\lambda$-Calculus to create the
simply-typed $\lambda$-Calculus.

The reader should have an understanding of programming
languages and a brief understanding of the untyped
$\lambda$-Calculus which is described in the first
chapter of ``Types and Programming Languages'' by
Benjamin C. Pierce \cite{pierce2002ProgLang}.
