\section{Introduction}

\epigraph{
    The road from untyped to typed universes has been followed many times,
    in many different fields, and largely for the same reasons.
}
{Luca Cardelli and Peter Wegner (1985)}

All modern programming languages have type systems.
They are either of a more dynamic nature - like JavaScript -
or statically typed like C\#. Functional languages like Haskell have
an even stricter form of a type system. They all have one thing in
common: They aid the developer to create programs without 
the constant fear of runtime errors.

This paper shall give the reader an idea of the steps that
are needed to create a type system and how it is applied to
an untyped language. This paper will use JavaScript - ish,
TypeScript\footnote{\url{https://www.typescriptlang.org/}} - ish
and Haskell\footnote{\url{https://www.haskell.org/}}
syntax as examples for certain comparisons.
Of course, JavaScript is not an untyped language, but
it does not have a strict static type analysis which can lead
to runtime errors during the interpretation and execution of the code.
TypeScript is a superset of the JavaScript language which fills this
gap and adds a static type analyzer as well as a type of compiler
(i.e., transpiler) to the language.

The result will be a simple type system, that can validate
type safety for a simply typed language. It does not include
any variants of subtyping like polymorphism. The remainder
of this paper will give further introduction into the topic,
a brief overview over the $\lambda$-Calculus, an overview
over the topic of ``types'' in general, and the application
of simple types to the untyped $\lambda$-Calculus to create the
simply-typed $\lambda$-Calculus as well as a list of simple
extensions to the simply-typed $\lambda$-Calculus which make
the language more practical and useful.

Why type systems are helpful and how they work
is not a trivial question to be answered. Consider
the following code statement:

\begin{minted}{JavaScript}
    foo = "Hello World"
    bar = 42
    foo - bar // NaN (Not a Number)
\end{minted}

As software developers, we understand that this statement
is not going to terminate well - assuming we have an untyped
language. Strings and numbers are not
of the same type and cannot be subtracted from one another. To determine
that this is not going to work, the computer needs to execute
the statements one by one and will encounter a wrong state.
A type system can prevent such errors and create a
human-readable message when compiling such a program.

The reader should have an understanding of programming
languages and a brief understanding of the untyped
$\lambda$-Calculus which is described in the first
chapter of ``Types and Programming Languages'' by
Benjamin C. Pierce \cite{pierce2002ProgLang}.
