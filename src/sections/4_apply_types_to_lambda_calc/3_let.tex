\subsection{Let Bindings}
\label{subsec:let}

Let bindings are a useful tool to avoid repetition in complex expressions.
They are found in Haskell as well:

\begin{minted}{Haskell}
    add x y =
        let result = x + y
        in
            result
\end{minted}

\subsubsection{Addition to the syntax \cite{pierce2002ProgLang}}
\begin{bnfgrammar}
    t ::= : terms$\colon$
    | \dots
    | let x = t in t : let binding
\end{bnfgrammar}\leavevmode\newline

\subsubsection{Addition to the evaluation rules \cite{pierce2002ProgLang}}
\begin{equation*}
    \tag{Let-Bind Value}
    \texttt{let } x = v_1 \texttt{ in } t_2 \rightarrow [x \mapsto v_1] t_2
\end{equation*}
In the given abstraction $t_2$, replace all occurencies of $x$ with $v_1$.

\begin{equation*}
    \tag{Let}
    \infer{
        \texttt{let } x=t_1 \texttt{ in } t_2 \rightarrow \texttt{let } x=t'_1 \texttt{ in } t_2
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
If there is a step from $t_1$ to $t'_1$, evaluate the step
in the syntax before evaluating the let binding itself.

\subsubsection{Addition to the typing rules \cite{pierce2002ProgLang}}
\begin{equation*}
    \tag{Let}
    \infer{
        \Gamma \vdash \texttt{let } x=t_1 \texttt{ in } t_2 \colon \texttt{T}_2
    }{
        \Gamma \vdash t_1 \colon \texttt{T}_1 & \Gamma , x \colon \texttt{T}_1 \vdash t_2 \colon \texttt{T}_2
    }
\end{equation*}
To calculate the type of the let binding, calculate the type of the bound term. The bound
term will yield the same type as the used term for the binding.
