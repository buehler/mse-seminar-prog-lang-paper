\subsection{Lists}

We've seen some ``base types'' like \texttt{Nat} or \texttt{Bool}
and ``type constructors'' records and variant types which build
new types out of old ones \cite{pierce2002ProgLang}.
To complete the list - pun intended - we introduce
``lists'' here. A list is a practical and useful type constructor
that describes a finite set of elements which are fetched from the
type of the list.
In addition to the list definition itself some useful helper
methods come along with it to make the list usable in a ``practical''
way.

Addition to the syntax \cite{pierce2002ProgLang}:
\begin{bnfgrammar}
    t ::= : terms$\colon$
    | \dots
    | nil[T] : empty list
    | cons[T] t t : list constructor
    | isnil[T] t : test for empty list
    | head[T] t : head of a list
    | tail[T] t : tail of a list
\end{bnfgrammar}\leavevmode\newline

\begin{bnfgrammar}
    v ::= : values$\colon$
    | \dots
    | nil[T] : empty list
    | cons[T] v v : list constructor
\end{bnfgrammar}\leavevmode\newline

\begin{bnfgrammar}
    T ::= : types$\colon$
    | \dots
    | List T : type of lists
\end{bnfgrammar}\leavevmode\newline

Addition to the evaluation rules \cite{pierce2002ProgLang}:
\begin{equation*}
    \tag{Cons Left}
    \infer{
        \texttt{cons[T] } t_1 t_2 \rightarrow \texttt{cons[T] } t'_1 t_2
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
``If there is a step from $t_1$ to $t'_1$, evaluate the term $t_1$
before the other terms or the list constructor''.

\begin{equation*}
    \tag{Cons Right}
    \infer{
        \texttt{cons[T] } v_1 t_2 \rightarrow \texttt{cons[T] } v_1 t'_2
    }{
        t_2 \rightarrow t'_2
    }
\end{equation*}
``If there is a step from $t_2$ to $t'_2$ and the lefthand side
is already reduced to a value, evaluate the term $t_2$
before the list constructor''.

\begin{equation*}
    \tag{IsNil of Nil}
    \texttt{isnil[S] (nil[T])} \rightarrow \texttt{true}
\end{equation*}
``The application of \texttt{isnil} to an empty list constructed
with \texttt{nil[]} must return \texttt{true}''.
\todo{why S in isnil? and not T?}

\begin{equation*}
    \tag{IsNil of Nil}
    \texttt{isnil[S] (cons[T]} v_1 v_2 \texttt{)} \rightarrow \texttt{false}
\end{equation*}
``The application of \texttt{isnil} to a non-empty list constructed
with \texttt{cons[]} and two values must return \texttt{false}''.

\begin{equation*}
    \tag{IsNil}
    \infer{
        \texttt{isnil[T] } t_1 \rightarrow \texttt{isnil[T] } t'_1
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
``If there is a step from $t_1$ to $t'_1$ evaluate the term $t$ first
until it is a value before evaluating the \texttt{isnil} function''.

\begin{equation*}
    \tag{Head of cons}
    \texttt{head[S] } (\texttt{cons[T] } v_1 v_2) \rightarrow v_1
\end{equation*}
``If the function \texttt{head} is applied to a list of values,
it returns the lefthand element (the head) of the list''.

\begin{equation*}
    \tag{Head}
    \infer{
        \texttt{head[T] } t_1 \rightarrow \texttt{head[T] } t'_1
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
``If there is a step from $t_1$ to $t'_1$ evaluate $t$ prior to applying
the head function to the term''.

\begin{equation*}
    \tag{Tail of cons}
    \texttt{tail[S] } (\texttt{cons[T] } v_1 v_2) \rightarrow v_2
\end{equation*}
``If the function \texttt{tail} is applied to a list of values,
it returns the righthand element (the tail) of the list''.

\begin{equation*}
    \tag{Tail}
    \infer{
        \texttt{tail[T] } t_1 \rightarrow \texttt{tail[T] } t'_1
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
``If there is a step from $t_1$ to $t'_1$ evaluate $t$ prior to applying
the tail function to the term''.

~\\
Addition to the typing rules \cite{pierce2002ProgLang}:
\begin{equation*}
    \tag{Nil}
    \Gamma \vdash \texttt{nil[T}_1\texttt{]} \colon \texttt{List T}_1
\end{equation*}
``The calculated type of the list \texttt{nil[T]} is \texttt{List T}''.

\begin{equation*}
    \tag{Constructor}
    \infer{
    \Gamma \vdash \texttt{cons[T}_1 \texttt{]} t_1 t_2 \colon \texttt{List T}_1
    }{
    \Gamma \vdash t_1 \colon \texttt{T}_1 & \Gamma \vdash t_2 \colon \texttt{List T}_1
    }
\end{equation*}
``If $t_1$ is of type $\texttt{T}_1$ and $t_2$ is a list of $\texttt{T}_1$,
then the cons(tructor) of a list with those two terms will also create
a list of type $\texttt{T}_1$''. This essentially allows the list constructor
to create consecutive lists of terms. Lists are not only limited to two elements.
This can be compared to the Haskell notation of the `:' (cons) operator, which
allows the creation of lists:

\begin{minted}{Haskell}
    -- this creates the list [1,2,3]
    list = 1:2:3:[]
\end{minted}

\begin{equation*}
    \tag{IsNil}
    \infer{
    \Gamma \vdash \texttt{isnil[T}_{11} \texttt{]} t_1 \colon \texttt{Bool}
    }{
    \Gamma \vdash t_1 \colon \texttt{List T}_{11}
    }
\end{equation*}
``If the term $t_1$ is a \texttt{List T}, then the application of
\texttt{isnil[T]} to this term $t_1$ must yield a \texttt{Bool} type''.

\begin{equation*}
    \tag{Head}
    \infer{
    \Gamma \vdash \texttt{head[T}_{11} \texttt{]} t_1 \colon \texttt{T}_{11}
    }{
    \Gamma \vdash t_1 \colon \texttt{List T}_{11}
    }
\end{equation*}
``If the term $t_1$ is a \texttt{List T}, then the application of
\texttt{head[T]} to this term $t_1$ must yield a type \texttt{T}''.

\begin{equation*}
    \tag{Tail}
    \infer{
    \Gamma \vdash \texttt{tail[T}_{11} \texttt{]} t_1 \colon \texttt{T}_{11}
    }{
    \Gamma \vdash t_1 \colon \texttt{List T}_{11}
    }
\end{equation*}
``If the term $t_1$ is a \texttt{List T}, then the application of
\texttt{tail[T]} to this term $t_1$ must yield a type \texttt{T}''.
