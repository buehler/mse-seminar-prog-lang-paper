\subsection{Exceptions}

The last but not least addition (i.e. simple extension) to the
simply typed $\lambda$-Calculus are exceptions. With the possibility
of references and general recursive functions, the need of
error handling arrises. Nearly all real-world programming languages
have some way of signaling that the function in question is not able
to carry out a given task \cite{pierce2002ProgLang}. In practical terms
this could be a division by zero. As seen in \ref{subsec:variants},
a function could just return a variant that is either a result or
some other variant of the type, but when something is truly exceptional,
the language should be able to throw an exception.

The following additions define the possibility to raise exceptions,
as well as a way of handling them when they occur.

Addition to the syntax \cite{pierce2002ProgLang}:
\begin{bnfgrammar}
    t ::= : terms$\colon$
    | \dots
    | raise t : raise an exception
    | try t with t : handle exceptions
\end{bnfgrammar}\leavevmode\newline

Addition to the evaluation rules \cite{pierce2002ProgLang}:
\begin{equation*}
    \tag{Application Raise 1}
    (\texttt{raise } v_{11}) t_2 \rightarrow \texttt{raise } v_{11}
\end{equation*}
``If the lefthand side of an application does raise some error value,
ignore the righthand side and raise the given error''.

\begin{equation*}
    \tag{Application Raise 2}
    v_1 (\texttt{raise } v_{21}) \rightarrow \texttt{raise } v_{21}
\end{equation*}
``If the lefthand side is reduced to a value and the righthand side does
raise an error, raise that error''. This rule with the rule ``Raise 1''
do guarantee that if either side of an application does raise an exception
the error will take precedence over the other term and/or value.

\begin{equation*}
    \tag{Raise}
    \infer{
        \texttt{raise } t_1 \rightarrow \texttt{raise } t'_1
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
``If there is a step from $t_1$ to $t'_1$, evaluate the term
before executing the \texttt{raise} application''.

\begin{equation*}
    \tag{Re-Raise}
    \texttt{raise } (\texttt{raise } v_{11}) \rightarrow \texttt{raise } v_{11}
\end{equation*}
``If \texttt{raise} is applied to a term that raises a value itself, re-raise that
value''.

\begin{equation*}
    \tag{Try Value}
    \texttt{try } v_1 \texttt{ with } t_2 \rightarrow v_1
\end{equation*}
``If a term is evaluated to a value and no error is risen, return
this value and ignore the term $t_2$''.

\begin{equation*}
    \tag{Try Error}
    \texttt{try } \texttt{raise } v_{11} \texttt{ with } t_2 \rightarrow t_2 v_{11}
\end{equation*}
``If a term is evaluated and raises an error, use the term $t_2$ (the exception
handler) and apply it to the value $v_{11}$''.

\begin{equation*}
    \tag{Try}
    \infer{
        \texttt{try } t_1 \texttt{ with } t_2 \rightarrow \texttt{try } t'_1 \texttt{ with } t_2
    }{
        t_1 \rightarrow t'_1
    }
\end{equation*}
``If there is a step from $t_1$ to $t'_1$, evaluate the term
before evaluating other elements like the error handler''.

~\\
Addition to the typing rules \cite{pierce2002ProgLang}:
\begin{equation*}
    \tag{Exception}
    \infer{
        \Gamma \vdash \texttt{raise } t_1 \colon \texttt{T}
    }{
        \Gamma \vdash t_1 \colon \texttt{T}_{exn}
    }
\end{equation*}
``If $t_1$ is a type that can be raised (i.e. it is
additional information to the error), then the whole
expression can be given the type \texttt{T} since it may be required
by the context''.

\begin{equation*}
    \tag{Try}
    \infer{
        \Gamma \vdash \texttt{try } t_1 \texttt{ with } t_2 \colon \texttt{T}
    }{
        \Gamma \vdash t_1 \colon \texttt{T}
        &
        \Gamma \vdash t_2 \colon \texttt{T}_{exn} \rightarrow \texttt{T}
    }
\end{equation*}
``If the first term $t_1$ is of type \texttt{T} and the second
term $t_2$ is an exception handler of type $\texttt{T}_{exn} \rightarrow \texttt{T}$,
then the resulting type of the \texttt{try ... with ...} expression will
be of type \texttt{T}''.
