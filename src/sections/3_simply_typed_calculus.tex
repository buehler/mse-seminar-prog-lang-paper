\section{Simply Typed Lambda-Calculus}

The mathematical abstraction of the $\lambda$-Calculus
is a topic that is not easy to understand if encountered
for the first time. The purpose of the present paper is to
describe the nature of the typed calculus with examples from
programming languages so that a developer can understand the
concepts.

% Short introduction sentence here.
% the following sub sections should describe
% the principles of the simply typed lambda calculus.

% \begin{itemize}
%     \item What are types
%     \item What can we do with them
%     \item further elements like base types
%     \item where is it used (lambda calculus)
% \end{itemize}

% each section should explain the topic in both ways.
% first the "math" way to explain what the topic is and
% then, the developer language version.

% The goal should be, that a developer can read those sections
% and can interpret what the simply typed lambda calculus is. Explained
% in terms and examples that a normal experienced developer should understand.

\subsection{Key Difference}

The simply typed calculus relies upon static type analysis.
This means, to determine if a program is \textit{well-typed}
(i.e. it compiles according to the given typing rules \cite{cardelliTypeSystems}), no
machine needs to run the program.

% We extend the untyped $\lambda$ grammar:

% \begin{bnfgrammar}
%     t ::= : terms$\colon$
%     | x : variable
%     | $\lambda$x.t : abstraction
%     | t t : application
% \end{bnfgrammar}

% \begin{bnf*}
%     \bnfprod{t}
%     {\bnfts{x} \bnfsp \bnftd{variable}}\\
%     \bnfmore{}
%     {\bnfts{$\lambda$x.}\bnfpn{t} \bnfsp \bnftd{abstraction}}\\
%     \bnfmore{}
%     {\bnfpn{t} \bnfpn{t} \bnfsp \bnftd{application}}
% \end{bnf*}

% And get the typed version that limits values and
% inputs to terms to certain types.

% \begin{bnfgrammar}
%     t ::= : terms$\colon$
%     | x$\colon$T : variable
%     | $\lambda$x$\colon$T.t : abstraction
%     | t t : application
% \end{bnfgrammar}

% \begin{bnf*}
%     \bnfprod{t}
%     {\bnfts{x\colorbox{lightgray}{:T}} \bnfsp \bnftd{variable}}\\
%     \bnfmore{}
%     {\bnfts{$\lambda$x\colorbox{lightgray}{:T}.}\bnfpn{t} \bnfsp \bnftd{abstraction}}\\
%     \bnfmore{}
%     {\bnfpn{t} \bnfpn{t} \bnfsp \bnftd{application}}
% \end{bnf*}

The limitation of the input can eliminate stuck states
and in conjunction with the normalization property \cite{pierce2002ProgLang} \cite{baader_nipkow_1998}
therefore eliminates turing completeness.

A program that successfully compiled in a simply typed
lambda system is guaranteed to run to completion and not
reaching any stuck states.

\subsection{Types}

Types in the mathematical language are not the same as a developer
might expect. A developer sees a type as \textit{bool} or \textit{string},
while a mathematician defines types as set of elements.

The typed calculus creates a typing context $\varGamma$ which is a
set of applied types in the program. During static analysis of the program, each
type that is encountered is inserted into this context and will be available
for type checking.

T el of varGamma

\todo{derivation trees for typings}

\subsection{Types in the $\lambda$-Calculus}

To enhance the given grammar with types so that our program
cannot take expressions like \textit{if succ(0) then true else false},
some typing restriction must be in place. As seen above, there is a
mathematical way to describe types. Consider the following code statement:

\begin{lstlisting}[caption={If Condition},captionpos=b]
    if <something boolean-ish> then
        // then statement
    else
        // else statement
    end if
\end{lstlisting}

To analyse this if condition, we need to define what
"boolean-ish" is.

\begin{bnfgrammar}
    T ::= : types$\colon$
    | Bool : type of booleans
\end{bnfgrammar}

Our typing grammar ("T") now contains the \textit{Bool} type
and the list of values ("v") contains the values for the
\textit{true} and \textit{false} constants. We need to add
typing rules to be able to parse this boolean expression:

true : Bool\\
false: Bool\\
t1: Bool     t2: T    t3: T\\
---------------------------\\
if t1 then t2 else t3 : T

This means that the condition after the \textit{if} must
be a Bool and the two branches of the condition must have
the same type.

To make this system more useful, we add natural numbers
as well with their corresponding type "Nat":

\begin{bnfgrammar}
    T ::= : types$\colon$
    | ...
    | Nat : type of natural numbers
\end{bnfgrammar}

And of course we need some additional typing rules:

0 : Nat\\
t1 : Nat\\
---------\\
succ t1: Nat\\
t1 : Nat\\
---------\\
pred t1: Nat\\
t1 : Nat\\
---------\\
iszero t1: Bool\\

We are not yet able to make meaningful applications, but
at least, we can guarantee that no program ever can
except a natural number for the conditional part of an if clause.
The type systems for modern languages work in such a way.
It should be noted though, that modern compilers have additional
extensions to their respective grammars, which make the language
turing complete again.

% Describe what types are and what types mean.
% In terms of mathematics and programming languages.

% Why they are needed for certain tasks.

% \begin{itemize}
%     \item example types
%     \item describe in math language
%     \item translate to "developer language"
%     \item why do we need them?
% \end{itemize}

Describe the different types and their context.
What are function types and how are they used.
What are the properties of typing.

Ref to Curry/Church

typescript example of church notation with typings.


\subsection{Extending types}

\begin{itemize}
    \item What hides behind "base types"
    \item the unit type (void)
    \item other typing constructs for the simple calculus
\end{itemize}

\subsection{References}

\begin{itemize}
    \item What is a reference type
\end{itemize}

\subsection{Error states}

\begin{itemize}
    \item What exactly is an exception
    \item How to throw / handle them
\end{itemize}
