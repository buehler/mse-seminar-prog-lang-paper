\section{Lambda Calculus}

A computer program can be described in multiple
ways. A. M. Turing defined the turing machine
in \cite{aturingMachine} in the year 1937. This
machine was an abstract model of computation.
In contrast to a "machine", the mathematical model
of a computer program was defined by Alonzo Church
\cite{churchLambda}. It uses mathematical logic
to run calculations and all elements can be described
in mathematical terms.

The untyped $\lambda$-Calculus is turing complete,
which means it can compute \textit{any} program and
therefore can run infinitely. This is a contrast to
the simply typed calculus, which limits the executable
terms in the way that they never reach an erroneous state.
In an untyped $\lambda$ system, it is possible to search
for the successor of "true", which
requires the argument to be a number and therefore
results in a stuck state.

Since it is not desirable for computer programs to run to infinity,
some basic method has been introduced \cite{churchLogic} to check for typing errors
and restrict malformed input from beeing inserted into a function
during compile time.

\todo{reference to simons paper}

For the further progress of this paper, it is necessary to recall
the grammar for arithmetic expressions of the untyped calculus \cite{pierce2002ProgLang}:

\begin{bnfgrammar}
    t ::= : terms$\colon$
    | true : constant true
    | false : constant false
    | if t then t else t : conditional
    | 0 : constant zero
    | succ t : successor
    | pred t : predecessor
    | iszero t : zero test
\end{bnfgrammar}

\begin{bnfgrammar}
    v ::= : values$\colon$
    | true : true value
    | false : false value
    | nv : numeric value
\end{bnfgrammar}

\begin{bnfgrammar}
    nv ::= : numeric values$\colon$
    | 0 : zero value
    | succ nv : successor value
\end{bnfgrammar}

% Very briefly describe the untyped lambda calculus
% with reference to the paper of Simon Gubler
% (which writes the paper for the untyped calculus)

% The brief description should provide an overview of
% terms and elements so that the reader can advance
% to the transition to the typed system.

% \begin{enumerate}
%     \item simple syntax example
%     \item simple rules
%           \begin{itemize}
%               \item variables
%               \item abstractions
%               \item applications
%           \end{itemize}
%     \item simple typescript example \cite{lambdaCalcInTS}
% \end{enumerate}
